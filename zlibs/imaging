#!/usr/bin/env zsh
#
# Copyright (c) 2016 Dyne.org Foundation
# libdevuansdk is written and maintained by
#     Jaromil <jaromil@dyne.org>
#     KatolaZ <katolaz@freaknet.org>
#     parazyd <parazyd@dyne.org>
#
# This file is part of libdevuansdk
#
# This source code is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This software is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this source code. If not, see <http://www.gnu.org/licenses/>.

## Imaging

vars+=(imgname imgpath)

img_mkimage() {
	fn img_mkimage $@
	imgpath=${strapdir}.img
	local mbrtype="$1"
	local bootfstype="$2"
	local rootfstype="$3"
	req=(imgpath imgsize mbrtype bootfstype rootfstype)
	ckreq || return 1

	imgname=`basename ${imgpath}`

	notice "Creating raw image..."
	silly
	dd if=/dev/zero \
		of="${imgpath}" \
		bs=1M count=${imgsize}

	if [[ $mbrtype == "dos" ]]; then
		img_partition_dos $bootfstype $rootfstype
	elif [[ $mbrtype == "gpt" ]]; then
		img_partition_gpt $bootfstype $rootfstype
	else
		error "No valid MBR type specified..."
		zerr; zshexit
	fi

	img_mount
	img_rsync_strapdir
	[[ -z $override_bootloader ]] && img_install_bootloader
	img_umount
}

img_partition_dos() {
	fn img_partition_dos $@
	local bootfstype="$1"
	local rootfstype="$2"
	req=(imgname imgpath bootfstype rootfstype)
	ckreq || return 1

	notice "Partitioning with dos"
	silly

	parted_boot=${parted_boot:-ext2 0 64}
	parted_root=${parted_root:-ext4 64 -1}

	pushd ${workdir}

	parted ${imgname} --script -- mklabel msdos
	parted ${imgname} --script -- mkpart primary ${parted_boot}
	parted ${imgname} --script -- mkpart primary ${parted_root}

	# setup loopdevice and mappdevice (zlibs/helpers)
	findloopmapp

	img_format_partitions ${bootfstype} ${rootfstype}

	popd
}

img_format_partitions() {
	fn img_format_partitions $@
	local bootfstype="$1"
	local rootfstype="$2"
	req=(bootfstype rootfstype bootpart rootpart)
	ckreq || return 1

	notice "Formatting partitions..."
	sudo mkfs.${bootfstype} ${bootpart}
	sudo mkfs.${rootfstype} ${rootpart}

}

img_partition_gpt() {
	fn img_partition_gpt $@
	local bootfstype="$1"
	local rootfstype="$2"
	req=(imgname imgpath bootfstype rootfstype)
	ckreq || return 1

	notice "Partitioning with gpt"
	silly

	pushd ${workdir}

	parted ${imgname} --script -- mklabel gpt
	cgpt create -z ${imgname}
	cgpt create ${imgname}
	cgpt add -i 1 -t kernel -b 8192 -s 32768 -l kernel -S 1 -T 5 -P 10 ${imgname}
	cgpt add -i 2 -t data -b 40960 -s `expr $(cgpt show ${imgname} \
		| awk '/Sec GPT table/ {print \$1}') - 40960` -l Root ${imgname}

	# setup loopdevice and mappdevice (zlibs/helpers)
	findloopmapp

	img_format_partitions ${bootfstype} ${rootfstype}

	popd
}

img_rsync_strapdir() {
	fn img_rsync_strapdir
	req=(workdir strapdir)
	ckreq || return 1

	notice "Rsyncing strapdir to raw image..."
	silly
	sudo rsync -HPavz -q ${strapdir}/* ${workdir}/rootp
}

img_install_bootloader() {
	fn img_install_bootloader

	conf_install_kernel ${workdir}/rootp
	conf_install_grub ${workdir}/rootp
}

img_mount() {
	fn img_mount
	req=(bootpart rootpart workdir)
	ckreq || return 1

	mkdir -p ${workdir}/rootp

	sudo mount ${rootpart} ${workdir}/rootp      && act "mounted root partition"
	sudo mkdir -p ${workdir}/rootp/{boot,dev,proc,sys}
	sudo mount ${bootpart} ${workdir}/rootp/boot && act "mounted boot partition"

	mountdevprocsys ${workdir}/rootp
}

img_umount() {
	fn img_umount
	req=(bootpart rootpart workdir)
	ckreq || return 1

	umountdevprocsys ${workdir}/rootp

	sudo umount ${workdir}/rootp/boot && act "umounted boot partition"
	sudo umount ${workdir}/rootp      && act "umounted root partition"
}
